#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//debug,调试版本，源代码，不进行优化，文件体积较大，程序员使用（包含调试信息）
//release,发布版本，优化后的代码，文件体积较小，调试员使用
//调试快捷键：ctrl+f5直接运行，f5启动调试（配合f9，设置好断点后进行调试，程序会直接执行至断点处
//此时再按f5会跳到下一个逻辑上的断点，即若是循环内断点，每按一次f5，循环一次），f9切换断点（逻辑上的断点）
// 
//断点也可直接点击语句左侧进行添加或取消，当首次已经发现在哪里出现问题（逻辑上，例如某次循环）时，可以打上断点
// 注意断点应打在循环体内
//右键断点选择条件，(例如输入循环变量的条件i==3)，f5调试将直接执行到该次循环处，从而节省调试时间！！！
// 
//f10逐过程进行调试（不进入函数内部），f11逐语句进行调试（进入函数内部，VS下库函数不进入）
//shift+f5停止调试，shift+f11同效果
//shift+f9快速监视，不常用
//调试→窗口→自动窗口（自动将上下文的变量加入或删除）、局部变量（自动将局部范围的变量加入或删除）都不常用
//常用监视窗口和内存窗口
//此外还有反汇编（得到汇编语言），寄存器（得到寄存器的值），调用堆栈（展示函数调用的逻辑顺序）等
//各种窗口都需要在调试进行时才能调出

//int main()
//{
//	int i = 0;
//	for (i = 0; i < 100; i++)
//	{
//		printf("%d ", i);
//	}
//
//	for (i = 0; i < 100; i++)
//	{
//		printf("%d ",10 - i);
//	}
//	//system("pause");
//	return 0;
//}

//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };//debug是死循环haha，但release会仅输出13个haha
//	for (i = 0; i <= 12; i++)
//	{
//		printf("haha\n");
//		arr[i] = 0;
//	}
//
//	return 0;
//}

//int add(int x, int y)
//{
//	return x + y;
//}
//
//int main()
//{
//	printf("haha\n");
//	int a = 10;
//	int b = 20;
//	int c = add(a, b);
//	printf("%d\n", c);
//
//	return 0;
//}

//int main()//内存与监视
//{
//	{
//		int tmp = 0;
//		printf("tmp = %d\n", tmp);
//	}
//	int arr[10] = { 0 };
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i;
//	}
//
//	return 0;
//}

//void test2()
//{
//	printf("haha\n");
//}
//
//void test1()
//{
//	test2();
//}
//
//void test(int i)
//{
//	test1();
//}
//
//int main()//调用堆栈
//{
//	int i = 0;
//	test(i);
//
//	return 0;
//}



//调试一段阶乘之和的代码

//int main()
//{
//	int i = 0;
//	int sum = 0;
//	int n = 0;
//	int ret = 1;
//	scanf("%d", &n);//n=3时应输出9，但实际输出了15
//	for (i = 1; i <= n; i++)
//	{
//		int j = 0;
//
//		for (j = 1; j <= i; j++)
//		{
//			ret *= j;//因为ret循环在内循环结束后未重置，应该将ret的初始化放在内层循环外而不是外层循环外
//		}
//		sum += ret;
//	}
//	printf("%d\n", sum);
//
//	return 0;
//}


//调试一段数组越界的代码
//注意：C语言不支持for循环内定义循环变量，C++才支持

//int main()
//{
//	int i = 0;//把int i=0放在数组定义后就不会产生这种问题（使i的地址在比数组地址低的地方）
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };//debug是死循环haha，但release会仅输出13个haha
//	//for (i = 0; i <= 12; i++)//会越界访问，把arr[10],arr[11],arr[12]改为0，但arr[12]与i是同一块内存空间
//	//						 //此时i也被改为0，因此产生死循环
//	//						 //数组的存储方式：在栈区存储，高地址放下标大的数组元素，低地址放下标小的元素
//	//						 //而栈区使用是先使用高地址（数组作为一个整体，内部元素存储按数组存储方式），会将i放在大于数组元素地址的地址，当前编译器恰好会
//	//						 //使其比数组最后一个元素地址大3的地址，正好会导致arr[12]地址等同于i的地址
//	//						 //陷入死循环后是没有机会进行数组越界的报错行为的，把i的判断条件改为11则避开死循环
//	//						 //此时会进行报错：数组越界访问
//	//{
//	//	printf("haha\n");
//	//	arr[i] = 0;
//	//}
//	printf("%p\n", &i);//i的地址是n+4*10+4*3,即相当于arr[12]的地址
//	printf("%p\n", arr);//假定arr地址为n
//	//release版本会改变arr和i的地址（实际改变了定义顺序），使i的地址为n-4*1，因此要注意release版本可能产生的差异
//	return 0;
//}