#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

//算术操作符（模运算和除运算），模运算只能用于整型操作数

//int main()
//{
//	int a = 5 / 2;//整数除法只能得商，无论正负
//	double b = 5 / 2.0;//操作数存在浮点数且变量为浮点型
//	printf("a = %d\n", a);//d为整型，输出2
//	printf("b = %lf\n", b);//lf为双精度浮点型，输出2.500000
//
//	int c = 5 % 2;//模运算得到余数，余数介于0到模数-1
//	//double d = 5 % 2.0;//模运算两侧操作数必须都是整型
//	printf("c = %d\n", c);
//	double d = 5 % 2;//但d可为浮点型
//	printf("d = %lf\n", d);//输出1.000000
//
//	return 0;
//}

//位移操作符，仅应用于整型操作数，不能移动负数位

/*int main()
{
	//右移分两种：算术右移右边截断，左边补原符号位，右移一次相当于/2
				//逻辑右移右边截断，左边补0（通常不采用逻辑移位，若采用逻辑右移需将整型转为无符号数）
	int a = 16;    //00000000000000000000000000010000→16
	a = a >> 2;//右移00000000000000000000000000000100→4
	int b = -16;   //10000000000000000000000000010000（原码）-16
				   //11111111111111111111111111101111（反码）
				   //11111111111111111111111111110000（补码）
	b = b >> 2;//右移11111111111111111111111111111100（补码）
				   //11111111111111111111111111111011（反码）
				   //10000000000000000000000000000100（原码）-4
	printf("a = %d\n", a);//输出4
	printf("b = %d\n", b);//输出-4
	//注意负数右移相当于对应的正数每次/2后有余数则+1，移完加负号
	int a1 = 5;      //00000000000000000000000000000101→5
	a1 = a1 >> 2;//右移00000000000000000000000000000001→1
	int b1 = -5;     //10000000000000000000000000000101（原码）-5
				     //11111111111111111111111111111010（反码）
				     //11111111111111111111111111111011（补码）
	b1 = b1 >> 2;//右移11111111111111111111111111111110（补码）
				     //11111111111111111111111111111101（反码）
				     //10000000000000000000000000000010（原码）-2
	printf("a1 = %d\n", a1);//输出1
	printf("b1 = %d\n", b1);//输出-2

	//左移就是右边补零，左边溢出，左移一次相当于*2
	int c = 16;    //00000000000000000000000000010000→16
	c = c << 2;//左移00000000000000000000000001000000→64
	int d = -16;   //10000000000000000000000000010000（原码）-16
				   //11111111111111111111111111101111（反码）
				   //11111111111111111111111111110000（补码）
	d = d << 2;//左移11111111111111111111111111000000（补码）
				   //11111111111111111111111110111111（反码）
				   //10000000000000000000000001000000（反码）-64
	printf("c = %d\n", c);//输出64
	printf("d = %d\n", d);//输出-64
	//左移没有特殊之处
	int c1 = 5;
	c1 = c1 << 2;
	int d1 = -5;
	d1 = d1 << 2;
	printf("c1 = %d\n", c1);//输出20
	printf("d1 = %d\n", d1);//输出-20

	return 0;
}*/

//位操作符，仅应用于整型操作数，对于变态的题目有效

//int main()
//{
//	int a = 3;    //00000000000000000000000000000011→3
//	int b = 5;    //00000000000000000000000000000101→5
//	int c = a & b;//00000000000000000000000000000001→1  都真则真
//	int d = a | b;//00000000000000000000000000000111→7  都假则假
//	int f = a ^ b;//00000000000000000000000000000110→6  同假异真
//	int g = ~a;   //11111111111111111111111111111100（补码）按位取反包括符号位
//				  //11111111111111111111111111111011（反码）
//				  //10000000000000000000000000000100（原码）-4
//	int a1=11;	     //00000000000000000000000000001011
//	//倒数第三位变为1  00000000000000000000000000000100 （按位或）1<<2
//	//得到结果         00000000000000000000000000001111
//	//等价于  a1 = a1|(1<<2);
//	//倒数第三位变为0  11111111111111111111111111111011（按位与）~(1<<2)
//	//得到原数a1=11    00000000000000000000000000001011
//	//等价于 a1 = a1&(~(1<<2))
//	printf("c = %d\n", c);//输出1
//	printf("d = %d\n", d);//输出7
//	printf("f = %d\n", f);//输出6
//	printf("g = %d\n", g);//输出-4
//	return 0;
//}

//赋值操作符

//int main()
//{
//	int a = 1;
//	int b = 2;
//	int x = 0;
//	x = a = a + b;//不建议链式赋值
//	//+=  -=  /=  %=  *=  >>=  <<=  &=  |=  ^=
//}

//逻辑操作符

//int main()
//{
//	//!的常用方法
//	int a = 0;
//	if (!a)//如果为假则执行
//	{
//		printf("haha\n");
//	}
//	if (a)//如果为真则执行
//	{
//		printf("hehe\n");
//	}
//
//	int x1 = 3;
//	int x2 = 0;
//	int y = 5;
//	int c1 = x1 && y;//1
//	int c2 = x2 || y;//1
//	printf("%d %d", c1,c2);
//
//	return 0;
//}

//单目操作符

//int main()
//{
//	//~（见位操作）  !（见逻辑操作）  *  &  sizeof  +（基本不用）  -（取相反数）  ++   --  (类型) 强制类型转换
//	
//	//指针
//	int a = 1;
//	int* pa = &a;
//	printf("a的值为%d，地址为%p\n", *pa, pa);
//
//	//sizeof，返回值为无符号数
//	int b = 10;
//	char c = 'h';
//	int arr1[10] = { 0 };
//	char arr2[10] = "hello";
//	int* pb = &b;
//	char* pc = &c;
//	int* parr1 = &arr1;
//	int* parr2 = &arr2;
//	//变量名可省略括号，数据类型不可省略括号
//	printf("%d\n", sizeof(b));//4
//	printf("%d\n", sizeof(c));//1
//	printf("%d\n", sizeof(arr1));//40
//	printf("%d\n", sizeof(int [10]));//int [10] 为arr1的类型，40
//	printf("%d\n", sizeof(arr2));//10
//	printf("%d\n", sizeof(char [10]));//char [10] 为arr2的类型，10
//	printf("%d\n", sizeof(pb));//4
//	printf("%d\n", sizeof(pc));//4
//	printf("%d\n", sizeof(parr1));//4，注意数组传参均为地址，在函数内sizeof(数组名)均为4
//	printf("%d\n", sizeof(parr2));//4
//	short x = 0;
//	int y = 20;
//	printf("%d\n", sizeof(x = y + 5));//4，sizeof内部的数值并未实际计算，仅将x类型转换为int
//	printf("%d\n", x);//0
//
//	//自增自减
//	int x1 = 10;
//	printf("%d\n", x1++);//打印10，但x1之后会变为11
//	printf("%d\n", ++x1);//x1会变为12，打印12
//
//	//强制类型转换
//	int num = (int)3.14;//括号括起的是类型而不是数据或变量
//
//	return 0;
//}

//比较操作符

//仅需注意=与==的区别

//条件操作符

//判断？执行1:执行2    判断为真执行1，判断为假执行2，通常用括号括起赋予其他变量

//逗号表达式，不熟练时少用

//int main()
//{
//	//int a = 1;
//	//int b = 2;
//	//int c = (a > b, a = b + 10, a, b = a + 1);//逗号表达式从左向右依次执行，但仅返回最右侧的值
//	//printf("%d", c);//a=12,b=13,c=b=13，输出13
//
//	//int a = 1;
//	//int b = 2;
//	//int c = 0;
//	//if (a = b + 1, c = a / 2, b > 0)//a=3,c=0,真
//	//{
//	//	printf("haha\n");//条件满足
//	//}
//
//	//假定有代码如下
//	//a=get_val();
//	//count_val(a);
//	//while (a > 0)
//	//{
//	//    其他操作
//	//    a = get_val();
//	//    count_val(a);
//	//}
//	//简化如下
//	//while (a = get_val(), count_val(a), a > 0)
//	//{
//	//	其他操作
//	//}
//
//	return 0;
//}

//下标引用操作符

//int main()
//{
//	int arr[10] = { 0 };
//	arr[4] = 10;
//	return 0;
//}

//函数调用操作符

//int get_max(int x, int y)//此处的括号为语法规则
//{
//	return x > y ? x : y;
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int max = get_max(a, b);//此处的括号为函数调用操作符，本函数调用操作符有三个操作数，get_max,a,b
//	printf("%d", max);      //函数调用操作符至少有一个操作数（不传参时，操作数只有函数名）
//}

//结构成员操作符

//创建一个结构体类型
//struct Stu//struct Stu为变量类型，struct为结构体关键字，Stu为标识符
//{
//	char name[20];
//	int age;
//	char id[20];//分号分隔
//};//分号结尾
//
//int main()
//{
//	int a = 10;
//	struct Stu s1 = { "杨佳奇",21,"201800061" };//创建变量s1，类型为struct Stu
//	printf("%s\n", s1.name);//访问结构体变量的成员（属性）
//	printf("%d\n", s1.age);
//	printf("%s\n", s1.id);
//	struct Stu* ps = &s1;//结构体指针
//	printf("%s\n", (*ps).name);//由地址找结构再找成员
//	printf("%s\n", ps->name);//找到该地址所对应的结构体的成员，更加简洁
//	return 0;
//}


//表达式求值

//类型转换
//隐式类型转换：整型提升（高位补符号位）（ALU的操作数大小一般就是int，对于不满足4个字节的需要转为4个字节）
//              算术转换（不同的类型运算将转换为其中最大的）

//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011，由于a为char只能放一个字节，因此3对应的二进制补码高位溢出，仅保留末8位
//	//00000011
//	char b = 127;
//	//00000000000000000000000001111111，同样溢出
//	//01111111
//	char c = a + b;//由于a,b不满足整型条件，需要进行整型提升（高位补符号位）
//	//00000000000000000000000010000010，同样溢出
//	//10000010 打印前进行整型提升
//	//11111111111111111111111110000010（补码）高位补符号位
//	//11111111111111111111111110000001（反码）
//	//10000000000000000000000001111110（原码）-126
//	printf("%d\n", c);//输出-126
//	return 0;
//}


//表达式求值的影响因素；优先级，结合性，是否控制求值顺序（&& || :?  ,）

//int main()//表达式未必能求出确定值
//{
//	//int a = 10;
//	//int b = 20;
//	//int c = b + a * 3;
//
//	//一些问题表达式，有效的避免问题表达式的方式是尽量将表达式拆分为按所需顺序的简单表达式
//
//	//a*b + c*d + e*f，*比+优先级高只能保证前两个**比第一个+早，不能保证第三个*比第一个+更早（即计算顺序是不确定的）
//	//假定这几个字母代表值将不影响结果，但当其分别是表达式时将影响表达式的结果（即计算结果未知）
//	//可能性其一  1a*b 2c*d 3a*b+c*d 4e*f 5a*b+c*d+e*f
//	//可能性其二  1a*b 2c*d 3e*f 4a*b+c*d 5a*b+c*d+e*f
//
//	//c + --c，--比+优先级高，但无法确定结果
//	//可能性一，--c中的c先获得值，例如1，则结果为0+0=0
//	//可能性二，左侧c先获得值，例如1，则结果为1+0=1
//
//	//int i=10;
//	//i = i-- - --i*(i=-3)*i++ + ++i;此处的i最终的值有多种可能，取决于编辑器
//
//	return 0;
//}