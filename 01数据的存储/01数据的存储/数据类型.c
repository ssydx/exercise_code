#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

//C语言类型有两种
//内置类型：整型（char short int long long），浮点型（float double  long double）
//自定义类型（构造类型）：数组，结构体，枚举，联合体
// 指针类型：int* char* float*等等
// 空类型：void常用于无返回值及无参数的函数类型，指针类型也会用到
// 
//无符号数与有符号数：以一个字节为例，有符号数-128~127，无符号数0~255
//整型都分有符号和无符号，默认有符号，即signed可省略
//short指short int，int可省略，long同理



//int main()
//{
//	int a = 10;				//0a 00 00 00
//	float f = 10.0;			//00 00 20 41
//	char ch = 'a';			//61 cc cc cc
//	unsigned char ch1 = 'a';//61 cc cc cc
//	short int x = 10;
//	short y = 10;
//	return 0;
//}



//void test(void)//使用void说明函数无参，仍可运行，但会产生警告
//{
//	printf("hello world\n");
//}
//
////void test()//test函数无参但仍可传参运行，且不报错，只不过参数并无意义
////{
////	printf("hello world\n");
////}
//
//int main()
//{
//	test(100);
//
//	return 0;
//}



//有符号的整型都有三种表示形式：原码，反码，补码（正数原反补相同，负数不同），无符号整型相当于全为正数
//浮点数不分有无符号也无原反补，采用另一种存储方式
//负数的原码+反码得到模数M - 1   模数指对应无符号数的取值个数
//反码+1得到补码
//负数的原码+补码得到模数M
//正数a-正数b → 正数a+负数-b → a+(-b) → a+b补 → a+(M-b)


//存储模式（以字节为单位）：大端存储是数据的低位放在高地址处，小端存储是数据的低位放在低地址处

//int main()
//{
//	int a = 10;		//0a 00 00 00（大端模式）
//	int b = -10;	//f6 ff ff ff（大端模式）
//	//10→ 00000000000000000000000000001010（原反补）
//	//10→    0   0   0   0   0   0   0   a
//	//10→                      00 00 00 0a
//	//-10→10000000000000000000000000001010（原码）
//	//-10→11111111111111111111111111110101（反码）
//	//-10→11111111111111111111111111110110（补码）
//	//-10→   f   f   f   f   f   f   f   6
//	//-10→                     ff ff ff f6
//	int c = 0x11223344; //c→44 33 22 11
//						//   11 22 33 44
//	return 0;
//}



#include <limits.h>
#include <float.h>

//浮点型的存储:(-1)^S * M * 2^E → S(1)E(8/11)M(23/52)，有效数字低位补0
//M：二进制的个位省略，即实际有效数字为24位
//E：无符号数，为了解决指数为负数的情况，E在实际保存时都会+127/1023
//取出E时对其再-127/1023，当E为全零时直接用E=1-127同时有效数字M不在加上个位的1，即M=0.xxxxxx
//当E为全一时，如果M全为0则表示±无穷大

int main()
{
	//double d = 1e3;
	//printf("%lf\n", d);//输出1000

	int n = 9;				//00000000000000000000000000001001
	float* pf = (float*)&n;	//0 00000000 00000000000000000001001（E全0则E=-126，M=0.00000000000000000001001）
	printf("%d\n",n);		//9
	printf("%f\n", *pf);	//0.000000，按浮点数输出，非常小以至于无法打印出有效位

	*pf = 9.0;				//1001.0 → (-1)^0 * 1.001 * 2^3 → 0 10000010 00100000000000000000000
	printf("%d\n", n);		//01000001000100000000000000000000是一个很大的数字
	printf("%f\n", *pf);

	return 0;
}